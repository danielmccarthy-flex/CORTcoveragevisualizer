<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Agency Coverage Heatmap</title>

  <!-- Vega stack -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>

  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: transparent;
    }
    #vis {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div style="padding:10px;display:flex;gap:12px;align-items:center">
    <label>Venue: <select id="venueSelect"><option value="All">All</option></select></label>
    <label>Agency: <select id="agencySelect"><option value="All">All</option></select></label>
    <button id="resetBtn">Reset</button>
  </div>

  <div style="display:flex;gap:12px;align-items:flex-start;padding:0 10px">
    <div id="vis" style="flex:1;height:calc(100vh - 120px)"></div>
    <div id="details" style="width:280px;padding:12px;border-left:1px solid #e3e3e3">
      <h3 style="margin:0 0 8px 0;font-size:15px">Details</h3>
      <div id="detailsContent" style="font-size:13px;color:#333">Hover a cell to see details here.</div>
    </div>
  </div>

  <script>
    // Load spec, populate dropdowns from data, and re-embed filtered spec
    let originalSpec = null;
    let originalData = null; // array of feature/records used by the visualization
    let venueField = null;
    let agencyField = null;

    function findDataArray(spec) {
      if (!spec) return null;
      // check compiled datasets (vega-lite compiled output)
      if (spec.datasets && typeof spec.datasets === 'object') {
        for (const k of Object.keys(spec.datasets)) {
          const v = spec.datasets[k];
          if (Array.isArray(v)) return v;
        }
      }
      // if spec.data names a dataset, resolve it
      if (spec.data && typeof spec.data === 'object' && spec.data.name && spec.datasets && spec.datasets[spec.data.name] && Array.isArray(spec.datasets[spec.data.name])) {
        return spec.datasets[spec.data.name];
      }
      // older/other specs may have data as an array of named sources
      if (spec.data) {
        if (Array.isArray(spec.data)) {
          for (let i = 0; i < spec.data.length; i++) {
            const d = spec.data[i];
            if (d && Array.isArray(d.values)) return d.values;
          }
        } else if (spec.data.values && Array.isArray(spec.data.values)) {
          return spec.data.values;
        }
      }
      return null;
    }

    function tryGetFieldName(record, candidates) {
      const keys = Object.keys(record || {});
      for (const c of candidates) {
        if (!c) continue;
        // direct match
        if (Object.prototype.hasOwnProperty.call(record, c)) return c;
      }
      // case-insensitive match
      for (const c of candidates) {
        const lower = keys.find(k => k.toLowerCase() === c.toLowerCase());
        if (lower) return lower;
      }
      // fallback: try common fields
      const common = ['Metro', 'metro', 'Display_Name', 'display_name', 'agency', 'agency_clean', 'name'];
      for (const cc of common) {
        const lower = keys.find(k => k.toLowerCase() === cc.toLowerCase());
        if (lower) return lower;
      }
      return null;
    }

    function getString(val) {
      if (val === null || val === undefined) return "";
      return String(val);
    }

    function populateSelect(selectEl, options) {
      // clear existing (keep first option for All)
      const first = selectEl.querySelector('option');
      selectEl.innerHTML = '';
      const allOpt = document.createElement('option');
      allOpt.value = 'All';
      allOpt.textContent = 'All';
      selectEl.appendChild(allOpt);
      options.forEach(opt => {
        const o = document.createElement('option');
        o.value = opt;
        o.textContent = opt;
        selectEl.appendChild(o);
      });
    }

    function prepareSpecForEmbed(spec) {
      const s = JSON.parse(JSON.stringify(spec));

      // ensure axis/grid styling for main chart
      if (s.encoding) {
        s.encoding.x = s.encoding.x || {};
        s.encoding.x.axis = s.encoding.x.axis || {};
        s.encoding.x.axis.grid = true;
        s.encoding.x.axis.labelAngle = s.encoding.x.axis.labelAngle || -45;
        s.encoding.x.axis.labelAlign = s.encoding.x.axis.labelAlign || 'right';
        s.encoding.x.axis.labelFontSize = s.encoding.x.axis.labelFontSize || 11;
        s.encoding.y = s.encoding.y || {};
        s.encoding.y.axis = s.encoding.y.axis || {};
        s.encoding.y.axis.grid = true;
        s.encoding.y.axis.labelFontSize = s.encoding.y.axis.labelFontSize || 11;
      }

      // create a small top chart that only renders the x-axis labels (no visible marks),
      // and vconcat it above the main chart to avoid axis property conflicts.
      try {
        const topSpec = {
          data: s.data,
          mark: { type: 'point', opacity: 0 },
          encoding: {
            x: Object.assign({}, s.encoding && s.encoding.x ? s.encoding.x : {}, { axis: Object.assign({}, (s.encoding && s.encoding.x && s.encoding.x.axis) || {}, { orient: 'top', labelAngle: 0, tickSize: 0, domain: false, grid: false, labelFontSize: 11 }) }),
            y: { value: 0 }
          },
          height: 40
        };

        const mainSpec = JSON.parse(JSON.stringify(s));

        // build vconcat spec while preserving top-level config and datasets
        const concatSpec = Object.assign({}, s);
        delete concatSpec.mark;
        delete concatSpec.encoding;
        delete concatSpec.data;
        concatSpec.vconcat = [topSpec, mainSpec];
        return concatSpec;
      } catch (e) {
        return s;
      }
    }

    function embedSpec(spec) {
      const prepared = prepareSpecForEmbed(spec);
      return vegaEmbed('#vis', prepared, { actions: false, renderer: 'canvas' });
    }

    function applyFilters() {
      if (!originalSpec || !originalData) return;
      const venueSel = document.getElementById('venueSelect').value;
      const agencySel = document.getElementById('agencySelect').value;

      const specCopy = JSON.parse(JSON.stringify(originalSpec));
      const dataArr = findDataArray(specCopy);
      if (!dataArr) {
        embedSpec(specCopy);
        return;
      }

      const filtered = originalData.filter(rec => {
        let ok = true;
        if (venueSel && venueSel !== 'All' && venueField) {
          ok = ok && getString(rec[venueField]).toLowerCase() === venueSel.toLowerCase();
        }
        if (agencySel && agencySel !== 'All' && agencyField) {
          ok = ok && getString(rec[agencyField]).toLowerCase() === agencySel.toLowerCase();
        }
        return ok;
      });

      // helper to replace data in various spec shapes (datasets, data, vconcat, layer)
      function replaceDataInSpec(s) {
        let replacedLocal = false;
        if (s.datasets && typeof s.datasets === 'object') {
          if (s.data && typeof s.data === 'object' && s.data.name && Array.isArray(s.datasets[s.data.name])) {
            s.datasets[s.data.name] = filtered;
            return true;
          }
          for (const k of Object.keys(s.datasets)) {
            if (Array.isArray(s.datasets[k])) {
              s.datasets[k] = filtered;
              return true;
            }
          }
        }
        if (s.data && Array.isArray(s.data)) {
          for (const d of s.data) {
            if (d && Array.isArray(d.values)) {
              d.values = filtered;
              return true;
            }
          }
        }
        if (s.data && s.data.values && Array.isArray(s.data.values)) {
          s.data.values = filtered;
          return true;
        }
        // handle vconcat or layer containing children with data
        if (Array.isArray(s.vconcat)) {
          for (const child of s.vconcat) {
            if (replaceDataInSpec(child)) return true;
          }
        }
        if (Array.isArray(s.layer)) {
          for (const child of s.layer) {
            if (replaceDataInSpec(child)) return true;
          }
        }
        return replacedLocal;
      }

      // replace the first data array found with filtered values
      let replaced = false;
      replaced = replaceDataInSpec(specCopy);
      embedSpec(specCopy);
    }

    fetch('Interactive_Agency_Coverage__Expansion_Map.json')
      .then(res => res.json())
      .then(spec => {
        originalSpec = spec;
        originalData = findDataArray(spec);

        // Filter out agencies with fewer than 10 total Venue_Count across metros
        if (originalData && originalData.length) {
          const aFieldGuess = tryGetFieldName(originalData[0], ['Display_Name','display_name','agency','agency_clean','Agency','provider','organization']);
          const totals = {};
          for (const r of originalData) {
            const name = getString(r[aFieldGuess]).trim();
            const vc = Number(r['Venue_Count'] || r['venue_count'] || 0) || 0;
            totals[name] = (totals[name] || 0) + vc;
          }
          const allowed = new Set(Object.keys(totals).filter(k => totals[k] >= 10));
          const filtered = originalData.filter(r => allowed.has(getString(r[aFieldGuess]).trim()));
          if (filtered.length) originalData = filtered;

          // also replace dataset in originalSpec so initial embed shows filtered data
          try {
            if (originalSpec.datasets && typeof originalSpec.datasets === 'object') {
              if (originalSpec.data && typeof originalSpec.data === 'object' && originalSpec.data.name && Array.isArray(originalSpec.datasets[originalSpec.data.name])) {
                originalSpec.datasets[originalSpec.data.name] = originalData;
              } else {
                const keys = Object.keys(originalSpec.datasets);
                if (keys.length) originalSpec.datasets[keys[0]] = originalData;
              }
            } else if (originalSpec.data && Array.isArray(originalSpec.data.values)) {
              originalSpec.data.values = originalData;
            }
          } catch (e) {
            console.warn('Could not update originalSpec datasets', e);
          }
        }

        if (originalData && originalData.length) {
          // try to detect field names
          const vField = tryGetFieldName(originalData[0], ['Metro','metro','venue', 'Venue', 'site', 'location', 'name', 'Display_Name']);
          const aField = tryGetFieldName(originalData[0], ['Display_Name','display_name','agency','agency_clean','Agency','provider','organization']);
          venueField = vField || 'Metro';
          agencyField = aField || 'Display_Name';

          const venues = Array.from(new Set(originalData.map(r => getString(r[venueField]).trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
          const agencies = Array.from(new Set(originalData.map(r => getString(r[agencyField]).trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));

          populateSelect(document.getElementById('venueSelect'), venues);
          populateSelect(document.getElementById('agencySelect'), agencies);

          document.getElementById('venueSelect').addEventListener('change', applyFilters);
          document.getElementById('agencySelect').addEventListener('change', applyFilters);
          document.getElementById('resetBtn').addEventListener('click', () => {
            document.getElementById('venueSelect').value = 'All';
            document.getElementById('agencySelect').value = 'All';
            applyFilters();
          });
        }

        // initial embed and attach interaction handlers
        embedSpec(spec).then(res => {
          try {
            const view = res.view;
            const detailsEl = document.getElementById('detailsContent');
            const show = d => {
              if (!d) { detailsEl.innerHTML = 'Hover a cell to see details here.'; return; }
              const agency = d['Display_Name'] || d['display_name'] || d['agency'] || d['agency_clean'] || '';
              const metro = d['Metro'] || d['metro'] || '';
              const local = d['Local_Margin_Str'] || d['Local_Margin'] !== undefined ? (d['Local_Margin_Str'] || (d['Local_Margin'] + '%')) : '';
              const global = d['Global_Avg_Margin_Str'] || d['Global_Avg_Margin'] !== undefined ? (d['Global_Avg_Margin_Str'] || (d['Global_Avg_Margin'] + '%')) : '';
              const venueCount = d['Venue_Count'] !== undefined ? d['Venue_Count'] : '';
              detailsEl.innerHTML = `<b>Agency:</b> ${agency}<br/><b>Metro:</b> ${metro}<br/><b>Venue Count:</b> ${venueCount}<br/><b>Local Margin:</b> ${local}<br/><b>Global Avg Margin:</b> ${global}`;
            };

            if (view && view.addEventListener) {
              view.addEventListener('mouseover', (event, item) => {
                if (item && item.datum) show(item.datum);
              });
              view.addEventListener('click', (event, item) => {
                if (item && item.datum) show(item.datum);
              });
              view.addEventListener('mouseout', () => show(null));
            }
          } catch (e) {
            console.warn('Could not attach interaction handlers', e);
          }
        }).catch(err => console.error('embed failed', err));
      })
      .catch(err => {
        console.error('Failed to load spec', err);
      });
  </script>
</body>
</html>
