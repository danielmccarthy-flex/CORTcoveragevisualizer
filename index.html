<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Agency Coverage Heatmap</title>

  <!-- Vega stack -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6"></script>

  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: transparent;
    }
    #vis {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div style="padding:10px;display:flex;gap:12px;align-items:center">
    <label>Venue: <select id="venueSelect"><option value="All">All</option></select></label>
    <label>Agency: <select id="agencySelect"><option value="All">All</option></select></label>
    <button id="resetBtn">Reset</button>
  </div>

  <div style="display:flex;gap:12px;align-items:flex-start;padding:0 10px">
    <div id="vis" style="flex:1;height:calc(100vh - 120px)"></div>
    <div id="details" style="width:280px;padding:12px;border-left:1px solid #e3e3e3">
      <h3 style="margin:0 0 8px 0;font-size:15px">Details</h3>
      <div id="detailsContent" style="font-size:13px;color:#333">Hover a cell to see details here.</div>
    </div>
  </div>

  <script>
    // Load spec, populate dropdowns from data, and re-embed filtered spec
    let originalSpec = null;
    let originalData = null; // array of feature/records used by the visualization

    function findDataArray(spec) {
      if (!spec) return null;
      // check compiled datasets (vega-lite compiled output)
      if (spec.datasets && typeof spec.datasets === 'object') {
        for (const k of Object.keys(spec.datasets)) {
          const v = spec.datasets[k];
          if (Array.isArray(v)) return v;
        }
      }
      // if spec.data names a dataset, resolve it
      if (spec.data && typeof spec.data === 'object' && spec.data.name && spec.datasets && spec.datasets[spec.data.name] && Array.isArray(spec.datasets[spec.data.name])) {
        return spec.datasets[spec.data.name];
      }
      // older/other specs may have data as an array of named sources
      if (spec.data) {
        if (Array.isArray(spec.data)) {
          for (let i = 0; i < spec.data.length; i++) {
            const d = spec.data[i];
            if (d && Array.isArray(d.values)) return d.values;
          }
        } else if (spec.data.values && Array.isArray(spec.data.values)) {
          return spec.data.values;
        }
      }
      return null;
    }

    function tryGetFieldName(record, candidates) {
      const keys = Object.keys(record || {});
      for (const c of candidates) {
        if (!c) continue;
        // direct match
        if (Object.prototype.hasOwnProperty.call(record, c)) return c;
      }
      // case-insensitive match
      for (const c of candidates) {
        const lower = keys.find(k => k.toLowerCase() === c.toLowerCase());
        if (lower) return lower;
      }
      // fallback: try common fields
      const common = ['Metro', 'metro', 'Display_Name', 'display_name', 'agency', 'agency_clean', 'name'];
      for (const cc of common) {
        const lower = keys.find(k => k.toLowerCase() === cc.toLowerCase());
        if (lower) return lower;
      }
      return null;
    }

    function getString(val) {
      if (val === null || val === undefined) return "";
      return String(val);
    }

    function populateSelect(selectEl, options) {
      // clear existing (keep first option for All)
      const first = selectEl.querySelector('option');
      selectEl.innerHTML = '';
      const allOpt = document.createElement('option');
      allOpt.value = 'All';
      allOpt.textContent = 'All';
      selectEl.appendChild(allOpt);
      options.forEach(opt => {
        const o = document.createElement('option');
        o.value = opt;
        o.textContent = opt;
        selectEl.appendChild(o);
      });
    }

    function prepareSpecForEmbed(spec) {
      const s = JSON.parse(JSON.stringify(spec));

      // enable gridlines on both axes where possible
      if (s.encoding) {
        s.encoding.x = s.encoding.x || {};
        s.encoding.x.axis = s.encoding.x.axis || {};
        s.encoding.x.axis.grid = true;
        s.encoding.x.axis.labelAngle = s.encoding.x.axis.labelAngle || -45;
        s.encoding.x.axis.labelAlign = s.encoding.x.axis.labelAlign || 'right';
        s.encoding.x.axis.labelFontSize = s.encoding.x.axis.labelFontSize || 11;
        s.encoding.y = s.encoding.y || {};
        s.encoding.y.axis = s.encoding.y.axis || {};
        s.encoding.y.axis.grid = true;
        s.encoding.y.axis.labelFontSize = s.encoding.y.axis.labelFontSize || 11;
      }

      // add a top axis by creating a transparent overlay layer that reuses the x encoding
      try {
        const bottomLayer = {
          mark: s.mark,
          encoding: s.encoding,
          data: s.data
        };

        const topEncoding = JSON.parse(JSON.stringify(s.encoding || {}));
        topEncoding.x = topEncoding.x || {};
        topEncoding.x.axis = Object.assign({}, topEncoding.x.axis || {}, { orient: 'top', labelAngle: 0, tickSize: 0, domain: false, grid: false, labelFontSize: 11 });

        const topLayer = {
          mark: { type: 'rect', opacity: 0 },
          encoding: topEncoding,
          data: s.data
        };

        // build layered spec while preserving datasets and config
        const layered = Object.assign({}, s);
        delete layered.mark;
        delete layered.encoding;
        delete layered.data;
        layered.layer = [bottomLayer, topLayer];
        return layered;
      } catch (e) {
        return s;
      }
    }

    function embedSpec(spec) {
      const prepared = prepareSpecForEmbed(spec);
      return vegaEmbed('#vis', prepared, { actions: false, renderer: 'canvas' });
    }

    function applyFilters() {
      if (!originalSpec || !originalData) return;
      const venueSel = document.getElementById('venueSelect').value;
      const agencySel = document.getElementById('agencySelect').value;

      const specCopy = JSON.parse(JSON.stringify(originalSpec));
      const dataArr = findDataArray(specCopy);
      if (!dataArr) {
        embedSpec(specCopy);
        return;
      }

      const filtered = originalData.filter(rec => {
        let ok = true;
        if (venueSel && venueSel !== 'All') {
          const vField = tryGetFieldName(rec, ['venue', 'Venue', 'site', 'location', 'name']);
          ok = ok && getString(rec[vField]).toLowerCase() === venueSel.toLowerCase();
        }
        if (agencySel && agencySel !== 'All') {
          const aField = tryGetFieldName(rec, ['agency', 'Agency', 'provider', 'organization']);
          ok = ok && getString(rec[aField]).toLowerCase() === agencySel.toLowerCase();
        }
        return ok;
      });

      // replace the first data array found with filtered values
      let replaced = false;
      if (specCopy.datasets && typeof specCopy.datasets === 'object') {
        // if data references a named dataset, replace that first
        if (specCopy.data && typeof specCopy.data === 'object' && specCopy.data.name && Array.isArray(specCopy.datasets[specCopy.data.name])) {
          specCopy.datasets[specCopy.data.name] = filtered;
          replaced = true;
        }
        if (!replaced) {
          for (const k of Object.keys(specCopy.datasets)) {
            if (Array.isArray(specCopy.datasets[k])) {
              specCopy.datasets[k] = filtered;
              replaced = true;
              break;
            }
          }
        }
      }
      if (!replaced && specCopy.data && Array.isArray(specCopy.data)) {
        for (const d of specCopy.data) {
          if (Array.isArray(d.values)) {
            d.values = filtered;
            replaced = true;
            break;
          }
        }
      }
      if (!replaced && specCopy.data && specCopy.data.values && Array.isArray(specCopy.data.values)) {
        specCopy.data.values = filtered;
      }
      embedSpec(specCopy);
    }

    fetch('Interactive_Agency_Coverage__Expansion_Map.json')
      .then(res => res.json())
      .then(spec => {
        originalSpec = spec;
        originalData = findDataArray(spec);

        if (originalData && originalData.length) {
          // try to detect field names
          const vField = tryGetFieldName(originalData[0], ['Metro','metro','venue', 'Venue', 'site', 'location', 'name', 'Display_Name']);
          const aField = tryGetFieldName(originalData[0], ['Display_Name','display_name','agency','agency_clean','Agency','provider','organization']);

          const venues = Array.from(new Set(originalData.map(r => getString(r[vField]).trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
          const agencies = Array.from(new Set(originalData.map(r => getString(r[aField]).trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));

          populateSelect(document.getElementById('venueSelect'), venues);
          populateSelect(document.getElementById('agencySelect'), agencies);

          document.getElementById('venueSelect').addEventListener('change', applyFilters);
          document.getElementById('agencySelect').addEventListener('change', applyFilters);
          document.getElementById('resetBtn').addEventListener('click', () => {
            document.getElementById('venueSelect').value = 'All';
            document.getElementById('agencySelect').value = 'All';
            applyFilters();
          });
        }

        // initial embed and attach interaction handlers
        embedSpec(spec).then(res => {
          try {
            const view = res.view;
            const detailsEl = document.getElementById('detailsContent');
            const show = d => {
              if (!d) { detailsEl.innerHTML = 'Hover a cell to see details here.'; return; }
              const agency = d['Display_Name'] || d['display_name'] || d['agency'] || d['agency_clean'] || '';
              const metro = d['Metro'] || d['metro'] || '';
              const local = d['Local_Margin_Str'] || d['Local_Margin'] !== undefined ? (d['Local_Margin_Str'] || (d['Local_Margin'] + '%')) : '';
              const global = d['Global_Avg_Margin_Str'] || d['Global_Avg_Margin'] !== undefined ? (d['Global_Avg_Margin_Str'] || (d['Global_Avg_Margin'] + '%')) : '';
              const venueCount = d['Venue_Count'] !== undefined ? d['Venue_Count'] : '';
              detailsEl.innerHTML = `<b>Agency:</b> ${agency}<br/><b>Metro:</b> ${metro}<br/><b>Venue Count:</b> ${venueCount}<br/><b>Local Margin:</b> ${local}<br/><b>Global Avg Margin:</b> ${global}`;
            };

            if (view && view.addEventListener) {
              view.addEventListener('mouseover', (event, item) => {
                if (item && item.datum) show(item.datum);
              });
              view.addEventListener('click', (event, item) => {
                if (item && item.datum) show(item.datum);
              });
              view.addEventListener('mouseout', () => show(null));
            }
          } catch (e) {
            console.warn('Could not attach interaction handlers', e);
          }
        }).catch(err => console.error('embed failed', err));
      })
      .catch(err => {
        console.error('Failed to load spec', err);
      });
  </script>
</body>
</html>
